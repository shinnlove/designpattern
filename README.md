# designpattern

设计模式


觉得看总结太单调，fork下来看看代码吧。


# 前情提要——简单工厂

**简单工厂不是一个标准设计模式。**

让客户端只知道接口、不知道具体实现，而设计工厂方法来生成具体实现的实例。把`new Impl()`放到工厂中，组件对外暴露的内容发生了改变，有质的变化。

## 1、时序步骤

- 客户端调用工厂静态方法创建接口
- 工厂根据**传参、配置文件或持久化的值**来选择并创建具体接口实现的实例并返回
- 客户端调用接口方法进行处理

## 2、多态来源种类

- 来源于客户端传入参数——客户端需要感知参数，一定程度上暴露了实现的种类
- 来源于配置文件——需要静态配置
- 来源于运行时的某个值，如缓存或DB

如果多态从配置文件中读入，如下：

```java
public static Api createApi() {
  // 从配置文件读入
  Properties p = new Properties();
  InputStream in = null;
  try {
    in = SimpleFactory.class.getResourceAsStream("FactoryTest.properties");
    p.load(in);
  } catch (IOException e) {
    
  // ......
```

再进行反射创建：

```java
Api api = null;
try {
  // ImplClass必须是全类名
  api = (Api) Class.forName(p.getProperty("ImplClass")).newInstance();
} catch (Exception e) {
// ......
```

既可以让客户端不感知、需求更改只要改配置文件、也可以抽象管理接口实现的创建。

## 3、本质

**选择实现。**

## 4、优缺点

### a) 优点

- 友好地实现组件封装，让客户端面向接口编程
- 解耦客户端与实现类

### b) 缺点

- 选择客户端传参增加复杂度和理解成本，可以选用配置来规避
- 不方便子类扩展，使用了静态方法创建接口实现的实例

## 5、使用时机

- 完全封装具体实现
- 集中管控对外创建对象的职责

## 6、模式关联

- 简单工厂用来选择实现、抽象工厂用来选择**产品簇**。抽象工厂退化只有一个产品实现不分层次就是简单工厂
- 工厂方法把选择具体实现延迟到子类去做，如果直接放在父类做就等于简单工厂
- 本质是选择实现的实例，可以与任何创建实例的模式配合使用：`单例`、`原型`、`生成器`模式等。

# 一、外观模式

客户端为了实现某个功能需要调用多个模块，还要知道如何组合非常麻烦，外观模式就是统筹多个模块，统一对客户端交互。比如双写各种场景都是组合了各种原子能力的。

职能：定义子系统多个模块对外的高层接口，通常调用内部多个模块，把具体的请求代理给不同的模块。

外观应该知道所有的子模块，子模块不应该感知外观存在。

## 1、UML

外观依赖所有需要调用到的模块的接口。

## 2、时序步骤

- 客户端调用外观的某个方法
- 外观调用模块A、模块B、模块C的功能，吃掉所有组合逻辑
- 外观根据调用结果返回给客户端最终结果

## 3、意义

- 兼顾组合功能和细节功能
- 提供缺省的功能实现

系统越做越大、功能越来越复杂。提高可重用性而抽象出很多的原子能力。如果用户并不想定制系统功能，而是使用缺省的一套组合来交互，则需要外观。

## 4、外观变种

- 可以让外观类的处理方法变成静态方法从而调用不同模块的API
- 可以把外观类设计成接口，配以工厂模式来生成具体外观的实现，从而减少模块API的暴露

第二种代码类数量会膨胀，实际工程中开发中褒贬不一。

## 5、本质

**封装交互、简化调用，很好的体现了最少知识原则**。

## 6、优缺点

### a) 优点

- 松散耦合
- 简单易用
- 划分访问层次

### b) 缺点

- 客户端调用Facade和原子能力之间的犹豫
- 类文件太多，层次太多

## 7、模式关联

- 与中介者模式

目的和职能互不相同：

**中介者模式主要用来封装多个对象之间的交互，多用在系统内部多个模块之间。**

**外观模式封装单向交互，是从客户端到系统调用，这是单向的。**

中介者模式吃掉了模块之间的耦合代码，让模块本身松散。

- 与单例模式

通常一个子系统只需要一个外观，可以结合单例使用。

- 与抽象工厂模式

外观通常需要知道多个模块的接口，可以通过抽象工厂来获取。而模块实现通过抽象工厂对Facade进行屏蔽。

**这也说明抽象工厂是一个产品簇，而不是单个接口API，与简单工厂的区别。**

# 二、适配器模式

当有了新接口，一般不要去重新实现或修改原来的代码，而是想办法做一些适配工作。

**将一个类的接口转换成客户希望的另外一个接口，适配器模式使得原本由于接口不兼容而不能一起工作的类可以一起工作。**

一般适配器与实现目标Target的接口，在具体实现中调用Adaptee的方法。

**智能适配器**：实现了一些在目标接口中定义的方法、而在被适配对象中没有的功能。

当Target中的某个功能需要多个被适配对象才能完成时，可以调用多个模块的功能。

## 1、时序步骤

- 客户端调用需要的功能
- 这个功能交给适配器来实现
- 适配器转调被适配对象的功能

## 2、适配方向

一般来说适配器是单向适配的，但是当不同客户需要以不同的方式访问相同对象的时候，可以做一个双向适配。

**双向适配器**：有老版本的`Api1`和实现、新版本的`Api2`和实现。双向适配器同时实现`Api1`和`Api2`两个接口。**当在老环境中操作老版本方法的时候，调用适配对象2的新方法；当在新环境中操作新方法的时候，调用适配对象1的老方法。**两种不同环境的不同适配，尤其适合**不同客户需要以不同的方式访问相同对象的时候**。

## 3、适配方式

根据适配实现的方式可以分为：对象适配器、类适配器。

### a) 适配方式与类图

**对象适配器**：依赖于对象组合，在适配方法中使用不同的组合方式处理。需要持有被适配的对象来复用原有能力。

![对象适配器类图](https://github.com/shinnlove/designpattern/blob/master/.common/composite-adapter%402x.png)

**类适配器**：采用继承被适配对象、同时实现新接口的方式进行适配。不需要持有被适配对象，本身继承已具备，当调用适配对象原有能力的时候，改成调用自己的方法。

![类适配器类图](https://github.com/shinnlove/designpattern/blob/master/.common/class-adapter51%402x.png)

### b) 共性与个性

- 从实现上：类适配器使用继承是一种静态方式；对象组合是一种动态方式
- 类适配器直接继承被适配对象，不能和被适配对象子类一起工作
- 类适配器可以重新定义Adaptee的行为，相当于`override`覆盖
- **建议尽量使用对象适配器**

## 4、本质

**转换匹配、复用功能。**

## 5、优缺点

### a) 优点

- 更好的复用性
- 更好的可扩展性——适配的时候加入自己的功能

### b) 缺点

适配器过多类太多，整体上不容易把控。

## 6、使用时机

- 使用一个已存在的类，但不符合你的需求，进行适配
- 创建一个可以复用的类，和一些不兼容的类一起工作
- 想使用一些已经存在的子类，不想对每一个进行适配，直接适配他们的父类

## 7、模式关联

- 与桥接模式



- 与装饰模式



- 与代理模式



- 与抽象工厂模式



# 三、单例模式



# 四、工厂方法模式



# 五、抽象工厂模式



# 六、生成器模式



# 七、原型模式



# 八、中介者模式



# 九、代理模式



# 十、观察者模式



# 十一、命令模式



# 十二、迭代器模式



# 十三、组合模式



# 十四、模板方法模式



# 十五、策略模式



# 十六、状态模式



# 十七、备忘录模式



# 十八、享元模式



# 十九、解释器模式



# 二十、装饰模式



# 二十一、职责连模式



# 二十二、桥接模式



# 二十三、访问者模式









