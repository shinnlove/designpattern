# designpattern

设计模式



觉得看总结太单调，fork下来看看代码吧。



# 前情提要——简单工厂

**简单工厂不是一个标准设计模式。**

让客户端只知道接口、不知道具体实现，而设计工厂方法来生成具体实现的实例。把`new Impl()`放到工厂中，组件对外暴露的内容发生了改变，有质的变化。

## 1、时序步骤

- 客户端调用工厂静态方法创建接口
- 工厂根据**传参、配置文件或持久化的值**来选择并创建具体接口实现的实例并返回
- 客户端调用接口方法进行处理

## 2、多态来源种类

- 来源于客户端传入参数——客户端需要感知参数，一定程度上暴露了实现的种类
- 来源于配置文件——需要静态配置，**J2EE的spring中常配置XML**
- 来源于运行时的某个值，如缓存或DB

如果多态从配置文件中读入，如下：

```java
public static Api createApi() {
  // 从配置文件读入
  Properties p = new Properties();
  InputStream in = null;
  try {
    in = SimpleFactory.class.getResourceAsStream("FactoryTest.properties");
    p.load(in);
  } catch (IOException e) {
    
  // ......
```

再进行反射创建：

```java
Api api = null;
try {
  // ImplClass必须是全类名
  api = (Api) Class.forName(p.getProperty("ImplClass")).newInstance();
} catch (Exception e) {
// ......
```

既可以让客户端不感知、需求更改只要改配置文件、也可以抽象管理接口实现的创建。

## 3、本质

**选择实现。**

## 4、优缺点

### a) 优点

- 友好地实现组件封装，让客户端面向接口编程
- 解耦客户端与实现类

### b) 缺点

- 选择客户端传参增加复杂度和理解成本，可以选用配置来规避
- 不方便子类扩展，使用了静态方法创建接口实现的实例

## 5、使用时机

- 完全封装具体实现
- 集中管控对外创建对象的职责

## 6、模式关联

- 简单工厂用来选择实现、抽象工厂用来选择**产品簇**。抽象工厂退化只有一个产品实现不分层次就是简单工厂
- 工厂方法把选择具体实现延迟到子类去做，如果直接放在父类做就等于简单工厂
- 本质是选择实现的实例，可以与任何创建实例的模式配合使用：`单例`、`原型`、`生成器`模式等。

# 一、外观模式

客户端为了实现某个功能需要调用多个模块，还要知道如何组合非常麻烦，外观模式就是统筹多个模块，统一对客户端交互。比如双写各种场景都是组合了各种原子能力的。

职能：定义子系统多个模块对外的高层接口，通常调用内部多个模块，把具体的请求代理给不同的模块。

外观应该知道所有的子模块，子模块不应该感知外观存在。

## 1、UML

外观依赖所有需要调用到的模块的接口。

## 2、时序步骤

- 客户端调用外观的某个方法
- 外观调用模块A、模块B、模块C的功能，吃掉所有组合逻辑
- 外观根据调用结果返回给客户端最终结果

## 3、意义

- 兼顾组合功能和细节功能
- 提供缺省的功能实现

系统越做越大、功能越来越复杂。提高可重用性而抽象出很多的原子能力。如果用户并不想定制系统功能，而是使用缺省的一套组合来交互，则需要外观。

## 4、外观变种

- 可以让外观类的处理方法变成静态方法从而调用不同模块的API
- 可以把外观类设计成接口，配以工厂模式来生成具体外观的实现，从而减少模块API的暴露

第二种代码类数量会膨胀，实际工程中开发中褒贬不一。

## 5、本质

**封装交互、简化调用，很好的体现了最少知识原则**。

## 6、优缺点

### a) 优点

- 松散耦合
- 简单易用
- 划分访问层次

### b) 缺点

- 客户端调用Facade和原子能力之间的犹豫
- 类文件太多，层次太多

## 7、模式关联

- 与中介者模式

目的和职能互不相同：

**中介者模式主要用来封装多个对象之间的交互，多用在系统内部多个模块之间。**

**外观模式封装单向交互，是从客户端到系统调用，这是单向的。**

中介者模式吃掉了模块之间的耦合代码，让模块本身松散。

- 与单例模式

通常一个子系统只需要一个外观，可以结合单例使用。

- 与抽象工厂模式

外观通常需要知道多个模块的接口，可以通过抽象工厂来获取。而模块实现通过抽象工厂对Facade进行屏蔽。

**这也说明抽象工厂是一个产品簇，而不是单个接口API，与简单工厂的区别。**

# 二、适配器模式

当有了新接口，一般不要去重新实现或修改原来的代码，而是想办法做一些适配工作。

**将一个类的接口转换成客户希望的另外一个接口，适配器模式使得原本由于接口不兼容而不能一起工作的类可以一起工作。**

一般适配器与实现目标Target的接口，在具体实现中调用Adaptee的方法。

**智能适配器**：实现了一些在目标接口中定义的方法、而在被适配对象中没有的功能。

当Target中的某个功能需要多个被适配对象才能完成时，可以调用多个模块的功能。

## 1、时序步骤

- 客户端调用需要的功能
- 这个功能交给适配器来实现
- 适配器转调被适配对象的功能

## 2、适配方向

一般来说适配器是单向适配的，但是当不同客户需要以不同的方式访问相同对象的时候，可以做一个双向适配。

**双向适配器**：有老版本的`Api1`和实现、新版本的`Api2`和实现。双向适配器同时实现`Api1`和`Api2`两个接口。**当在老环境中操作老版本方法的时候，调用适配对象2的新方法；当在新环境中操作新方法的时候，调用适配对象1的老方法。**两种不同环境的不同适配，尤其适合**不同客户需要以不同的方式访问相同对象的时候**。

## 3、适配方式

根据适配实现的方式可以分为：对象适配器、类适配器。

### a) 适配方式与类图

**对象适配器**：依赖于对象组合，在适配方法中使用不同的组合方式处理。需要持有被适配的对象来复用原有能力。

![对象适配器类图](https://github.com/shinnlove/designpattern/blob/master/.common/composite-adapter%402x.png)

**类适配器**：采用继承被适配对象、同时实现新接口的方式进行适配。不需要持有被适配对象，本身继承已具备，当调用适配对象原有能力的时候，改成调用自己的方法。

![类适配器类图](https://github.com/shinnlove/designpattern/blob/master/.common/class-adapter51%402x.png)

### b) 共性与个性

- 从实现上：类适配器使用继承是一种静态方式；对象组合是一种动态方式
- 类适配器直接继承被适配对象，不能和被适配对象子类一起工作
- 类适配器可以重新定义Adaptee的行为，相当于`override`覆盖
- **建议尽量使用对象适配器**

## 4、本质

**转换匹配、复用功能。**

## 5、优缺点

### a) 优点

- 更好的复用性
- 更好的可扩展性——适配的时候加入自己的功能

### b) 缺点

适配器过多类太多，整体上不容易把控。

## 6、使用时机

- 使用一个已存在的类，但不符合你的需求，进行适配
- 创建一个可以复用的类，和一些不兼容的类一起工作
- 想使用一些已经存在的子类，不想对每一个进行适配，直接适配他们的父类

## 7、模式关联

- 与桥接模式

**适配器模式：把两个或多个接口的功能进行转换匹配**；

**桥接模式：让接口和实现相分离、并相对独立的变化**。

- 与装饰模式

如果在调用目标代理方法的前后加上自定义处理，就与装饰模式有一定类似。

**两种设计模式都是用对象组合，可以在组合功能前后进行一些附加的处理，但是目的和本质都不一样。**

- 与代理模式

如果被代理对象Adaptee有一层代理，则可以与代理模式结合使用。

- 与抽象工厂模式

被代理对象如果是接口实现的实例，可以使用`抽象工厂`、`单例`、`工厂方法`等模式来得到这个实例。

# 三、单例模式

在系统运行时期，某些类只需要一个实例就够了——如配置文件。如果存在多个实例，则会浪费空间与内存。

控制一个类只创建一个实例，首要问题就是把创建实例的权限收回，让类自身来负责创建工作。

**构造函数私有化、类中有成员变量持有自身、提供静态方法返回自身某个实例。**

## 1、创建类型

单例模式的创建类型有`饿汉式`和`懒汉式`。前者在定义域变量的时候就直接实例化，每次调用创建方法都返回已经构建好的实例。后者只有在第一次被用到的时候才去懒实例化。

Map类型的数据结构在JDK中经常被用来作为的缓存，设置为静态的Map。当没有某个值的时候创建所需数据或内容，当有某个值的时候直接取出。

## 2、范围

单例是指`JVM`层面、确切的说是同一个`ClassLoader`加载下的某个类的唯一实例。不同`ClassLoader`下可以有多个实例。如果一台机器上布置了多个`JVM`环境，则也可以在一台机器上有多个实例。

## 3、本质

**控制实例数量。**

## 4、优缺点

### a) 优点

- 全局唯一的一份实例，节省空间


- 饿汉式时间换空间
- 懒汉式空间换时间

### b) 缺点

- 懒汉式本身是线程不安全的，需要进行加锁双重检查
- 懒汉式的实例需要带上关键字`volatile`，让每个线程使用它的时候能及时看到其他线程做出的改动

就是先判断，需要操作的话，进行：一锁二判断三处理，累积两次判断、中间一次加锁。

## 5、线程安全的延时加载

**类级内部类：有`static`修饰的成员式内部类。**

**对象级内部类：没有`static`修饰的成员式内部类。**

**类级内部类相当于外部类的`static`成分，只在某个`ClassLoader`加载外部类的时候被加载。**

**类级内部类可以定义静态方法，只能引用外部类中静态成员与方法。**

采用静态初始化器的方式，由JVM来保证线程安全性。JVM隐式执行同步情况包括如下：

- 由静态初始化器、`static{}`初始化数据时
- 访问`final`字段时
- 在创建线程之前创建对象时
- 线程可以看见它将要处理的对象时

以下是线程安全的延时加载单例方法：

```java
public class Singleton {
  
  private static class SingletonHolder {
    private static Singleton INSTANCE = new Singleton();
  }
  
  private Singleton(){
    // 私有化构造器
  }
  
  public static Singleton getInstance() {
    return SingletonHolder.INSTANCE;
  }
  
}
```

当虚拟机加载到`Singleton`类的时候并不会加载到`类级内部类`。而当调用`getInstance()`方法的时候，会加载到`SingletonHolder`这个`类级内部类`，而这个类加载的时候静态域会被初始化一次，直接返回`Singleton`的实例。因此既没有占用空间，也保证了线程安全。

**这种设计在`Spring`源代码中常有体现，会经常看到`XXXHolder`的类。**

## 6、模式关联

- 当某些模式中需要返回某个实例而只需要一个的时候
- 当某些模式中的某些类只需要一个实例的时候

# 四、工厂方法模式



# 五、抽象工厂模式



# 六、生成器模式



# 七、原型模式



# 八、中介者模式



# 九、代理模式



# 十、观察者模式



# 十一、命令模式



# 十二、迭代器模式



# 十三、组合模式



# 十四、模板方法模式



# 十五、策略模式



# 十六、状态模式



# 十七、备忘录模式



# 十八、享元模式



# 十九、解释器模式



# 二十、装饰模式



# 二十一、职责连模式



# 二十二、桥接模式



# 二十三、访问者模式









